C_Coding_Rules
# C 编写规范 
> 可参考：
> [C/C++]: https://blog.csdn.net/m0_67597657/article/details/135318429


## Basic Rules

### 命名规范
1. 标识符的命名建议使用unix风格的下划线命名法，具有明确含义，使用完整单词或通用缩写。
```C
char *my_name;
```
2. 使用用正确的反义词命名具有互斥意义的变量或相反动作；
3. 外购芯片的配套驱动或外部模块代码的修改应保持其原有风格；
4. 文件命名使用小写字符。
5. **全局变量增加“g_”前缀，静态变量增加“s_”前缀，以提醒谨慎使用;typedef定义的类型增加“_t”后缀。**
6. 函数命名应以函数要执行的动作命名，**一般采用动词或者动词＋名词；**
7. 对于数值、枚举、字符串等**常量，建议采用全大写字母、单词之间加下划线“_”**的方式命名;

### 头文件内部.h
1. 头文件中应放置**对外部的声明，如对外提供的函数声明、宏定义、类型定义等**
2. .c内部使用的函数声明、宏定义、类型定义等，不应放入头文件;
3. 头文件中**放置接口声明，不放置接口实现**;公用inline函数除外。
4. 全局变量定义**不应**放在头文件中。
5. 全局变量声明尽量不要放在头文件中，**不要使用全局变量作为接口，而是使用函数接口**

### 头文件依赖
1. 防止依赖复杂/循环依赖——头文件里，**除非必要，不要依赖其他头文件**;
2. 每个.c尽量有一个同名.h对应，必然没有外部接口除外;
3. 依赖原则：不稳定依赖稳定的，例如app依赖driver；driver依赖HAL/库/bsp;
4. 头文件应自包含编译，例如.c中依赖了a.h与b.h,这两个**头文件的先后顺序不应对编译产生影响**；
5. 用宏定义防止头文件重复包含
```C
    #ifndef ___H_FILE_NAME_H___
```
6. **禁止**在.c中通过 **extern** 的方式使用外部函数接口、变量,必须通过头文件调用；
7. 添加C++调用C函数原型申明:
```C
    #if defined(__cplusplus)
    extern "C" {
    #endif
    函数原型
    #ifdef __cplusplus
    }
    #endif
```
8. 禁止在 extern "C" 中包含头文件。
反之，可能破坏被包含头文件里接口的链接规范。正确示例：
```C
    #include “xxx.h”
    #if defined(__cplusplus)
    extern "C" {
    #endif
    //函数原型
    #ifdef __cplusplus
    }
    #endif
```

### 变量 宏 常量
1. 不对外部暴露的全局变量**加static**
2. 局部变量与全局变量**不要同名**
3. 对外暴露的全局变量应提供**函数接口来设置、获取**，同时注意**使用互斥**
4. 不要使用数据类型默认转换，类型**显示转换**
5. 用宏定义表达式时，要使用完备的**括号**
```C 
#define RECT_AREA(a, b) ((a) * (b))


```
6. 多条语句则必须放在**do {} while(0)**中，可以规避很多问题：
> https://blog.csdn.net/luoweifu/article/details/38563161
```C
#define DELETE_B_WITH_A(a, b)
    do{
        if((a)){
            (b) = NULL;
        }
    }while(0)

/* 调用就和正常函数一样 */
a=1;
b=6;
DELETE_B_WITH_A(a,b);

```

7. 使用宏时，带入的**参数不允许做变化操作**
```C 
#define SQUARE(a) ((a) * (a))

/* 禁止 */
SQUARE(a++);
```

8. 不要重定义或取消定义标准库中的保留宏定义（比如__DATE__, __TIME__）

9. 跨处理器使用的struct定义里不能包含enum类，应使用stdint.h里位宽明确的数据类型;

## 函数（后续细化学习）
1. 重复代码应该尽可能提炼成函数，一个函数只完成一个功能。
2. 尽量避免函数过长或代码块嵌套过深（建议不超过5层）。
3. 线程栈大小不超过16KB，算法函数栈大小不超过512B。
4. 函数设计要考虑高扇入，合理扇出（小于7，调度函数除外）。这里，扇出是指一个函数直接调用其它函数的数目，而扇入是指有多少函数调用它。
5. 调用者负责对函数参数合法性做检查:
> 该规则参考华为及Linux 规范，主要为防止层层调用中的ASSERT检查增加消耗；

    被调用者宜使用assert确保入参符合其输入要求
    对于某些无法保证有效的参数，或一些为保持通用等原则进行的兼容设计，则显式地识别并按要求做相应的错误/状态返回
    
    但是assert应只在开发/联试阶段打开，用以限制使用其的开发者规范其调用行为
    归档代码，除特殊情况外，assert都应该是通过模块feature配置默认关闭
    这样也解决了过多assert导致的性能/code size等问题

6. 函数的不变参数使用const修饰。
7. 函数参数个数建议**不超过4个**（参数过多，调用时会增加参数入栈、出栈操作耗时）。
8. 函数返回的错误码需要有特定意义，调用者应对错误码做相应处理。
9. 可重入函数应避免使用共享变量；若要使用，则应通过互斥手段对其加以保护。
10. 废弃代码（没有被调用的函数和变量）要及时清除，暂时保留的可以使用__attribute__((deprecated))修饰。
11. 不对外部暴露的函数加static属性。

## 表达式（尚有疑问）
1. 复合表达式分解成若干简单表达式，避免依赖默认优先级，**明确表达式的优先级执行次序**
```C 
/* 禁止; 函数传参从右往左压栈，此处需明确执行顺序 */
x = func( i++, i);

/* 明确写为 */
i++; 
x = func(i, i);

//TODO：详细拆解优先级顺序关系

```

2. 宏、函数的传参**禁止使用++或--**
3. 调用函数时不要使用另一个函数调用作为其参数，打印语句除外;(如何做到？函数指针传参算这类吗？)
4. 禁止if条件中写赋值语句（why？是因为会被编译器优化掉吗？）

## 注释（尚有疑问）
1. 优秀的代码可以自我解释，不通过注释即可轻易读懂。 
2. 一般在**头文件里加注释**；不在头文件里的**静态函数、结构体**等，在其**定义处**注释。
3. 对代码的功能、意图进行注释说明，而不是简单描述代码本身，注释内容要清晰。
4. 修改代码时需要维护注释，以保证注释与代码的一致性。
5. 对于switch下的case语句，如因特殊情况，需要执行完一个case后不break，接着进入下一个case中执行，须在下一个case语句前加上明确的注释，以免后续维护者误认为是遗漏break语句（后续自我筛查）
6. 注释风格统一
7. 文件头、函数头、类型/宏定义、结构体/枚举定义的注释采用doxygen语法规范，以便导出注释形成帮助文档（有空学一下）

## 排版与格式(vscode Astyle 插件)
1. 使用linux K&R风格的大括号（把起始大括号放在行尾，而把结束大括号放在行首）。
```C 
if (a > b) {
    ... ...
} else {
    ... ...
}

```
2. 程序块采用缩进风格编写，每级缩进为4个空格。
3. 相对独立的程序块之间、变量说明之后必须加空行。
4. 语句不宜过长（建议单行不超过128字符），若过长需要分行，换行时增加一级缩进，使代码可读性更好。
5. 代码书写时适当增加空格可以使代码更清晰。


## 代码编辑/编译(后续细化学习)
1. 所有文件采用UTF-8编码。
2. 使用编译器的**最高告警级别**，通过修改代码而不是降低告警级别来消除所有告警。
3. 如果必须禁用某个告警，应尽可能单独局部禁用，并且编写注释说明屏蔽原因。
4. 建议使用PC-Lint做代码检查。


## 可测性(后续细化学习)
1. 模块划分按照高内聚、低耦合原则，前置条件、输入及预期输出明确，便于单元测试。
2. 可通过编译开关开启/关闭调试模式、日志级别，采用统一的打印函数输出日志，日志包含函数名、行号信息。
3. 使用断言对模块内部的假设条件进行检查。
4. 准备好单元测试用例。
